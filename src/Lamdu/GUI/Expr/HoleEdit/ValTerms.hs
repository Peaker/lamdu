module Lamdu.GUI.Expr.HoleEdit.ValTerms
    ( holeSearchTerm
    , allowedSearchTerm
    ) where

import qualified Data.Char as Char
import qualified Data.Text as Text
import qualified Lamdu.CharClassification as Chars
import qualified Lamdu.I18N.Code as Texts
import qualified Lamdu.I18N.CodeUI as Texts
import           Lamdu.Name (Name(..), Collision(..))
import qualified Lamdu.Name as Name
import           Lamdu.Sugar.Types

import           Lamdu.Prelude

collisionText :: Name.Collision -> Text
collisionText NoCollision = ""
collisionText (Collision i) = Text.pack (show i)
collisionText UnknownCollision = "?"

ofName :: Name -> [Text]
ofName Name.Unnamed{} = []
ofName (Name.AutoGenerated text) = [text]
ofName (Name.NameTag x) =
    [ displayName
        <> collisionText textCollision
        <> collisionText (x ^. Name.tnTagCollision)
    ]
    where
        Name.TagText displayName textCollision = x ^. Name.tnDisplayText

ofNonOperator :: Name -> [Text]
ofNonOperator n
    | Name.isOperator n = []
    | otherwise = ofName n

holeSearchTerm ::
    (Has (Texts.Code Text) env, Has (Texts.CodeUI Text) env) =>
    env -> HoleTerm Name -> [Text]
holeSearchTerm _ (HoleGetDef x) =
    ofName x >>= maybePrefixDot
    where
        maybePrefixDot n
            | Name.isOperator x = [n]
            | otherwise = [n, "." <> n]
holeSearchTerm _ (HoleName x) = ofName x
holeSearchTerm _ (HoleGetField x) = ofNonOperator x <&> ("." <>)
holeSearchTerm e (HoleInject x) = ofNonOperator x <&> (e ^. has . Texts.injectSymbol <>)
holeSearchTerm _ (HoleFromNom x) = ofNonOperator x <&> ("." <>)
holeSearchTerm e HoleLet = [e ^. has . Texts.let_]
holeSearchTerm e HoleLambda = [e ^. has . Texts.lambda, "\\", "Λ", "λ", "->", "→"]
holeSearchTerm e HoleIf = [e ^. has . Texts.if_]
holeSearchTerm e HoleCase = ["." <> e ^. has . Texts.case_]
holeSearchTerm e HoleEmptyCase = [e ^. has . Texts.absurd]
holeSearchTerm _ HoleRecord = ["{}", "()", "[]"]
holeSearchTerm e HoleParamsRecord = [e ^. has . Texts.paramsRecordOpener]

allowedSearchTerm :: Text -> Bool
allowedSearchTerm searchTerm =
    any (searchTerm &)
    [ Text.all (`elem` Chars.operator)
    , isNameOrPrefixed
    , (`Text.isPrefixOf` "{}")
    , (== "\\")
    , -- Allow typing records in wrong direction of keyboard input,
      -- for example when editing in right-to-left but not switching the input language.
      -- Then the '}' key would had inserted a '{' but inserts a '}'.
      -- In this case it would probably help to still allow it
      -- as the user intended to create a record.
      (== "}")
    ]

isNameOrPrefixed :: Text -> Bool
isNameOrPrefixed t =
    case Text.uncons t of
    Nothing -> True
    Just (x, xs) | x `elem` prefixes -> isAlphaNumericName xs
    Just _ -> isAlphaNumericName t
    where
        prefixes :: String
        prefixes = ".'"

isAlphaNumericName :: Text -> Bool
isAlphaNumericName suffix =
    case Text.uncons suffix of
    Nothing -> True
    Just (x, xs) -> Char.isAlpha x && Text.all Char.isAlphaNum xs
